## 并查集

树状数据结构,两个操作:

1. 查询.查询某个元素属于哪个集合.
2. 合并.合并两个集合.

### 查询
在并查集中,我们会设置代表元素,同属于一个集合的所有元素,都会指向同一个代表元素,这样可以根据所查询元素的代表元素来判断其属于哪一个集合.

朴素的实现方法:

```python
fa = [0] * MAXN # 记录某个人的爸爸是谁，特别规定，祖先的爸爸是他自己
def find(x):
    # 寻找x的祖先
    if fa[x] == x:
        return x # 如果x是祖先则返回
    else:
        return find(fa[x]) # 如果不是则 x 的爸爸问 x 的爷爷
```

可以看出,所有的元素组成了一颗或多颗树.这样虽然能够实现我们想要的结果,但是并不能直接得出祖先,与我们的想法不符,需要的时间复杂度会较大.那么我们可以将每个子节点都直接连到作为代表元素的根节点上.

路径压缩:

```python
fa = [0] * MAXN # 记录某个人的爸爸是谁，特别规定，祖先的爸爸是他自己
def find(x):
    # 寻找x的祖先
    if x != fa[x]: # x 不是自身的父亲，即 x 不是该集合的代表
        fa[x] = find(fa[x]) # 查找 x 的祖先直到找到代表，于是顺手路径压缩
    return fa[x]
```

### 合并



实现方法:

```python
def unionSet(x, y):
    # x 与 y 所在家族合并
    x = find(x)
    y = find(y)
    fa[x] = y # 把 x 的祖先变成 y 的祖先的儿子
```

并不在意祖先究竟是谁，所以只要其中一个祖先变成另一个祖先的儿子就可以了。

启发式合并:

```python
size = [1] * N # 记录并初始化子树的大小为 1
def unionSet(x, y):
    xx = find(x); yy = find(y)
    if xx == yy:
        return
    if size[xx] > size[yy]: # 保证小的合到大的里
        xx, yy = yy, xx
    fa[xx] = yy
    size[yy] = size[yy] + size[xx]
```

